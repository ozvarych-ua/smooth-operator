<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dot Flow Playground</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        sans-serif;
    }
    body {
      margin: 0;
      background: #141414;
      color: #f5f5f5;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    .app {
      display: flex;
      flex: 1;
    }
    .canvas-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: radial-gradient(circle at center, #1f1f1f, #101010);
    }
    canvas {
      background: #232323;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      max-width: 100%;
      max-height: 100%;
    }

    .controls {
      width: 340px;
      max-width: 40vw;
      padding: 20px 20px 24px;
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      gap: 16px;
      background: #161616;
    }
    .controls h1 {
      margin: 0 0 4px;
      font-size: 20px;
      font-weight: 600;
    }
    .controls p.subtitle {
      margin: 0 0 16px;
      font-size: 12px;
      color: #a0a0a0;
    }
    .section {
      padding: 12px 10px 14px;
      border-radius: 10px;
      background: #1c1c1c;
      border: 1px solid #262626;
    }
    .section h2 {
      margin: 0 0 10px;
      font-size: 13px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #b3b3b3;
    }

    .field {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .field label {
      font-size: 13px;
      color: #ddd;
      flex: 1;
    }
    .field input[type="range"] {
      flex: 2;
    }
    .field small {
      font-size: 11px;
      color: #aaa;
      min-width: 28px;
      text-align: right;
    }

    .color-input {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .color-input label {
      font-size: 13px;
      color: #ddd;
      flex: 1;
    }
    .color-input input[type="color"] {
      width: 40px;
      height: 24px;
      border-radius: 6px;
      border: none;
      padding: 0;
      background: transparent;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .btn {
      border-radius: 999px;
      padding: 7px 12px;
      border: 1px solid #2b2b2b;
      background: #202020;
      color: #f5f5f5;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: background 0.12s ease, border-color 0.12s ease,
        transform 0.08s ease;
    }
    .btn:hover {
      background: #262626;
      border-color: #3a3a3a;
    }
    .btn:active {
      transform: scale(0.97);
    }
    .btn.primary {
      background: #2563eb;
      border-color: #3b82f6;
    }
    .btn.primary:hover {
      background: #1d4ed8;
      border-color: #2563eb;
    }
    .btn.small {
      padding: 5px 10px;
      font-size: 11px;
    }
    .btn.active {
      background: #3b82f6;
      border-color: #60a5fa;
    }

    .export-note {
      margin-top: 6px;
      font-size: 11px;
      color: #a3a3a3;
      line-height: 1.4;
    }
    .footer {
      margin-top: auto;
      font-size: 11px;
      color: #777;
      text-align: left;
    }
    .footer code {
      color: #ddd;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrapper">
      <!-- canvas 2056x2056 -->
      <canvas id="canvas" width="2056" height="2056"></canvas>
    </div>
    <div class="controls">
      <h1>Dot Flow Playground</h1>
      <p class="subtitle">
        Play with shapes, motion and colors, then export a video of the animation.
      </p>

      <div class="section">
        <h2>Animation</h2>
        <div class="field">
          <label for="speed">Speed</label>
          <input
            id="speed"
            type="range"
            min="0.05"
            max="0.8"
            step="0.01"
            value="0.25"
          />
          <small id="speedValue">0.25</small>
        </div>
      </div>

      <div class="section">
        <h2>Motion</h2>
        <div class="button-row">
          <button class="btn small active" data-motion="flow">
            Flow into hole
          </button>
          <button class="btn small" data-motion="breathe">
            Inhale / Exhale
          </button>
        </div>
      </div>

      <div class="section">
        <h2>Dot Shape</h2>
        <div class="button-row">
          <button class="btn small active" data-dotshape="circle">Circle</button>
          <button class="btn small" data-dotshape="square">Square</button>
          <button class="btn small" data-dotshape="triangle">Triangle</button>
        </div>
      </div>

      <div class="section">
        <h2>Colors</h2>
        <div class="color-input">
          <label for="dotColor">Dot color</label>
          <input id="dotColor" type="color" value="#f6f6f6" />
        </div>
        <div class="color-input">
          <label for="bgColor">Background</label>
          <input id="bgColor" type="color" value="#232323" />
        </div>
      </div>

      <div class="section">
        <h2>Export</h2>
        <button class="btn primary" id="exportBtn">
          Export 5s video
        </button>
        <div class="export-note">
          Uses <code>MediaRecorder</code> on the canvas stream.  
          Most browsers save as <strong>WebM</strong>. Convert to MP4 with a converter
          or <code>ffmpeg</code> if needed.
        </div>
      </div>

      <div class="footer">
        Canvas resolution: <code>2056×2056</code>.  
        Scales visually, export keeps full resolution.
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // UI elements
    const speedSlider = document.getElementById("speed");
    const speedValue = document.getElementById("speedValue");
    const dotColorInput = document.getElementById("dotColor");
    const bgColorInput = document.getElementById("bgColor");
    const motionButtons = document.querySelectorAll("[data-motion]");
    const dotShapeButtons = document.querySelectorAll("[data-dotshape]");
    const exportBtn = document.getElementById("exportBtn");

    // Settings
    const settings = {
      speed: parseFloat(speedSlider.value),
      dotColor: dotColorInput.value,
      bgColor: bgColorInput.value,
      motion: "flow",        // "flow" or "breathe"
      dotShape: "circle",    // "circle" | "square" | "triangle"
      dotCount: 420,
      innerHoleRatio: 0.20,
      outerRadiusRatio: 0.46,
      minDotR: 0.6,          // ~1 px
      maxDotRFactor: 0.004,  // relative to width
      waveAmpFactor: 0.012,
    };

    const goldenAngle = Math.PI * (3 - Math.sqrt(5));

    // UI handlers
    speedSlider.addEventListener("input", () => {
      settings.speed = parseFloat(speedSlider.value);
      speedValue.textContent = settings.speed.toFixed(2);
    });

    dotColorInput.addEventListener("input", () => {
      settings.dotColor = dotColorInput.value;
    });

    bgColorInput.addEventListener("input", () => {
      settings.bgColor = bgColorInput.value;
    });

    motionButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        motionButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        settings.motion = btn.dataset.motion;
      });
    });

    dotShapeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        dotShapeButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        settings.dotShape = btn.dataset.dotshape;
      });
    });

    // Drawing helpers for dot shapes
    function drawDotShape(x, y, r) {
      const shape = settings.dotShape;

      if (shape === "circle") {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      } else if (shape === "square") {
        ctx.beginPath();
        ctx.rect(x - r, y - r, 2 * r, 2 * r);
        ctx.fill();
      } else if (shape === "triangle") {
        // equilateral triangle centered at (x, y)
        const h = r * Math.sqrt(3);
        ctx.beginPath();
        ctx.moveTo(x, y - (2 / 3) * h);
        ctx.lineTo(x - r, y + (1 / 3) * h);
        ctx.lineTo(x + r, y + (1 / 3) * h);
        ctx.closePath();
        ctx.fill();
      }
    }

    // Animation
    function drawFrame(timestamp) {
      const t = timestamp * 0.001;

      const w = canvas.width;
      const h = canvas.height;
      const cx = w / 2;
      const cy = h / 2;

      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = settings.bgColor;
      ctx.fillRect(0, 0, w, h);

      const innerHole = w * settings.innerHoleRatio;
      const outerRadius = w * settings.outerRadiusRatio;
      const maxDotR = w * settings.maxDotRFactor;
      const waveAmp = w * settings.waveAmpFactor;

      ctx.fillStyle = settings.dotColor;

      for (let i = 0; i < settings.dotCount; i++) {
        const baseIndex = i / settings.dotCount;
        let radialNorm; // 0..1 (0 -> near hole, 1 -> outer)

        if (settings.motion === "flow") {
          // dots falling into the hole (main mode)
          const p = (baseIndex + t * settings.speed) % 1; // progress inward
          radialNorm = 1 - p;                             // 1 outer -> 0 inner
        } else {
          // inhale/exhale: dots breathe in-place
          // fixed index in [0..1], modulated by sine wave
          const base = baseIndex;
          const osc = Math.sin(t * settings.speed * 2 + base * 6);
          const amount = 0.15; // how far they move radially
          radialNorm = base * (1 - amount) + (base * osc + base) * amount;
          radialNorm = Math.max(0, Math.min(1, radialNorm));
        }

        // map radialNorm to radius between hole and edge
        const baseRadius =
          innerHole + radialNorm * (outerRadius - innerHole);

        // extra small wobble so it feels alive
        const wavePhase = radialNorm * 9.0;
        const rOffset = Math.sin(t * 2.0 + wavePhase) * waveAmp;
        const radius = baseRadius + rOffset;

        const angle = i * goldenAngle;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);

        // smooth size curve: small near hole/edge, biggest mid
        const level = Math.pow(radialNorm, 0.9);
        const sizeCurve = Math.sin(Math.PI * level);
        const dotR =
          settings.minDotR + sizeCurve * (maxDotR - settings.minDotR);

        // alpha: fade near hole, etc.
        const alpha = 0.12 + 0.88 * level;
        ctx.globalAlpha = alpha;

        drawDotShape(x, y, dotR);
      }

      ctx.globalAlpha = 1;
      requestAnimationFrame(drawFrame);
    }

    requestAnimationFrame(drawFrame);

    // Export video using MediaRecorder
    let isRecording = false;
    let recorder = null;
    let recordedChunks = [];

    exportBtn.addEventListener("click", () => {
      if (isRecording) {
        recorder && recorder.stop();
        return;
      }

      let stream;
      try {
        stream = canvas.captureStream(60);
      } catch (e) {
        alert("MediaRecorder/canvas captureStream not supported in this browser.");
        return;
      }

      try {
        recorder = new MediaRecorder(stream, {
          mimeType: "video/webm;codecs=vp9",
        });
      } catch (e) {
        alert("MediaRecorder failed to start.");
        return;
      }

      recordedChunks = [];
      recorder.ondataavailable = (ev) => {
        if (ev.data && ev.data.size > 0) {
          recordedChunks.push(ev.data);
        }
      };

      recorder.onstop = () => {
        isRecording = false;
        exportBtn.textContent = "Export 5s video";

        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:.]/g, "-");
        a.href = url;
        a.download = `dot-flow-${ts}.webm`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      };

      recorder.start();
      isRecording = true;
      exportBtn.textContent = "Recording… click to stop";

      setTimeout(() => {
        if (isRecording) recorder.stop();
      }, 5000);
    });
  </script>
</body>
</html>
